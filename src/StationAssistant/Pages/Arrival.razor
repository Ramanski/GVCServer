@page "/arrival"
@inject StationAssistant.Services.IGvcDataService GvcDataFetch
@inject StationAssistant.Services.IStationDataService StationData
@inject StationAssistant.Services.NotificationService NotificationService
@inject NavigationManager NavigationManager
@inject AuthenticationStateProvider authProvider

@using Microsoft.AspNetCore.SignalR.Client
@using Syncfusion.Blazor.Buttons
@using Syncfusion.Blazor.Popups
@attribute [AuthorizeRoles(Role.Admin, Role.DSC, Role.DSP)]

<div class="col-lg-12 control-section">
    <h3 class="text-center"> Прогноз прибытия поездов </h3>
    <div class="row">
        <div class="col-xs-4 col-sm-6 col-lg-12 col-md-12">
            <SfButton Disabled="!ArrivingTrainIsSelected" IsPrimary="true" IconCss="e-icons e-arriving" OnClick="(async() => await Arrived())">Оформить прибытие</SfButton>
            <SfButton Disabled="!ArrivingTrainIsSelected" IsPrimary="false" IconCss="e-icons e-tgnl" OnClick="(async() => await GetDetails())">Получить ТГНЛ</SfButton>
            <SfButton Disabled="!ArrivingTrainIsSelected" IsPrimary="false" IconCss="e-icons e-arriving-path" OnClick="(() => onOpenPathSelector(true))">Выбрать путь</SfButton>
        </div>
    </div>
    <div class="content-wrapper">
        <div class="row">
            <TrainList @ref="arrivingList" trainList="arrivingTrains" ShowDislAndOper="true" IsSelected="@(() => { ArrivingTrainIsSelected = true; })" IsDeselected="@(() => { ArrivingTrainIsSelected = false; })"></TrainList>
        </div>
    </div>
</div>
<div class="col-lg-12 control-section mt-1">
    <h3 class="text-center"> Прибывшие поезда </h3>
    <div class="col-xs-4 col-sm-6 col-lg-12 col-md-12">
        <SfButton IsPrimary="true" Disabled="@(!ArrivedTrainIsSelected)" IconCss="e-icons e-disband" OnClick="(async() => await Disband())">Расформировать</SfButton>
        <SfButton IsPrimary="false" Disabled="@(!ArrivedTrainIsSelected)" IconCss="e-icons e-relocate" OnClick="(() => onOpenPathSelector(false))">Переставить состав</SfButton>
        <SfButton IsPrimary="false" Disabled="@(!ArrivedTrainIsSelected)" IconCss="e-icons e-arriving-cancel" OnClick="onCancel">Отменить прибытие</SfButton>
    </div>
    <div class="content-wrapper">
        <div class="row">
            <TrainList @ref="arrivedList" trainList="arrivedTrains" IsSelected="@(() => { ArrivedTrainIsSelected = true; })" IsDeselected="@(() => { ArrivedTrainIsSelected = false; })"></TrainList>
        </div>
    </div>
</div>

@if (TrainCompositionVisible || PathSelectorVisible)
{
    <ConfirmModal Title="@TitleModal" DialogClose="onCloseModal" OverlayClick="onCloseModal" OKClick="onOK" Width=@(PathSelectorVisible?"450":"850") Height="@(PathSelectorVisible?"180":"80%")">
        @if (TrainCompositionVisible)
        {
            <TrainComposition trainModel="selectedTrainModel"/>
        }
        else if (PathSelectorVisible)
        {
            <PathSelector @ref="pathSelector" selectedTrain="selectedTrainModel" isArriving="ShowArrivingPathsOnly" />
        }
    </ConfirmModal>
}
    <SfDialog @bind-Visible="@CancelDialogIsVisible" Width="400px" Target="#target" ShowCloseIcon="true" Header="@Title" Content="@Body">
        <DialogButtons>
            <DialogButton Content="Да" IsPrimary="true" OnClick="(async() => {CancelDialogIsVisible = false; await CancelArrival(); })" />
            <DialogButton Content="Нет" OnClick="(() => { CancelDialogIsVisible = false; })" />
        </DialogButtons>
    </SfDialog>

<style>
</style>


@code {
    PathSelector pathSelector;
    TrainList arrivingList;
    TrainList arrivedList;
    private List<TrainModel> arrivingTrains { get; set; }
    private List<TrainModel> arrivedTrains { get; set; }
    TrainModel selectedTrainModel;
    private string TitleModal { get; set; }
    private bool TrainCompositionVisible { get; set; } = false;
    private bool PathSelectorVisible { get; set; } = false;
    private bool CancelDialogIsVisible { get; set; } = false;

    private bool ShowArrivingPathsOnly = false;
    public bool ArrivingTrainIsSelected { get; set; } = false;
    public bool ArrivedTrainIsSelected { get; set; } = false;
    private string Title;
    private string Body;
    private HubConnection hubConnection;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            arrivedTrains = await StationData.GetArrivedTrainsAsync();
            arrivingTrains = await GvcDataFetch.GetArrivingTrains();
        }
        catch (Exception e)
        {
            if (e is RailProcessException)
            {
                NotificationService.SetMessage(TypeNotification.Warning, e.Message);
            }
            else
            {
                NotificationService.SetMessage(TypeNotification.Error, $"Не удалось загрузить поезда");
            }
        }

        hubConnection = new HubConnectionBuilder().WithUrl(NavigationManager.ToAbsoluteUri("/trainshub")).Build();
        hubConnection.On<string, TrainModel>("TrainArrived", (user, train) =>
            {
                NotificationService.SetMessage(user, $"Поезд {train.Num} прибыл на станцию");
                arrivingList.DeleteTrain(train);
                train.DateOper = DateTime.Now;
                arrivedList.AddTrain(train);
            });
        await hubConnection.StartAsync();
    }

    async Task NotifyArrived(){
        var authState = await authProvider.GetAuthenticationStateAsync();
        var userName = authState.User.Identity.Name;
        await hubConnection.SendAsync("SendArrived", userName, arrivingList.selectedTrain);
    }

    public async ValueTask DisposeAsync()
    {
        await hubConnection.DisposeAsync();
    }
    private async Task GetDetails()
    {
        try
        {
            selectedTrainModel = await GvcDataFetch.GetTrainInfo(arrivingList.selectedTrain.Id);
        }
        catch (Exception e)
        {
             if (e is RailProcessException)
            {
                NotificationService.SetMessage(TypeNotification.Warning, e.Message);
            }
            else
            {
                NotificationService.SetMessage(TypeNotification.Error, "Не удалось выполнить операцию");
            }
        }
        onOpenList();
    }

    void onCloseModal()
    {
        PathSelectorVisible = false;
        TrainCompositionVisible = false;
    }

    void onOpenList()
    {
        TitleModal = "Телеграмма-натурный лист поезда №" + selectedTrainModel.Num;
        TrainCompositionVisible = true;
    }

    async Task onOK()
    {
        if (PathSelectorVisible && pathSelector != null)
        {
            try
            {

                if (ShowArrivingPathsOnly)
                {
                    var train = arrivingList.selectedTrain;
                    train.Path = await StationData.GetPathAsync(pathSelector.PathId);
                    arrivingList.UpdateSelectedRow(train);
                    NotificationService.SetMessage(TypeNotification.Success, $"Путь прибытия для поезда №{selectedTrainModel.Num} установлен");
                }
                else
                {
                    var train = arrivedList.selectedTrain;
                    await StationData.RelocateTrain(selectedTrainModel.Id, pathSelector.PathId);
                    train.Path = await StationData.GetPathAsync(pathSelector.PathId);
                    arrivedList.UpdateSelectedRow(train);
                    NotificationService.SetMessage(TypeNotification.Success, $"Перестановка поезда №{selectedTrainModel.Num} на другой путь завершена");
                }
            }
            catch (Exception)
            {
                NotificationService.SetMessage(TypeNotification.Error, "Не удалось установить путь для поезда");
            }
        }
        onCloseModal();
    }

    void onOpenPathSelector(bool ShowOnlyArriving)
    {
        selectedTrainModel = (ShowOnlyArriving ? arrivingList.selectedTrain : arrivedList.selectedTrain);
        if (selectedTrainModel == null)
        {
            NotificationService.SetMessage(TypeNotification.Info, "Выберите поезд из списка");
            return;
        }
        ShowArrivingPathsOnly = ShowOnlyArriving;
        TitleModal = $"Выбор пути для поезда {selectedTrainModel.Num}";
        PathSelectorVisible = true;
    }

    private async Task Arrived()
    {
        selectedTrainModel = arrivingList.selectedTrain;

        if (selectedTrainModel.Path == null)
        {
            NotificationService.SetMessage(TypeNotification.Warning, "Выберите путь приема");
            return;
        }

        try
        {
            await GvcDataFetch.SendTrainArrivedAsync(selectedTrainModel.Id, DateTime.Now);
            await StationData.AddTrainAsync(selectedTrainModel.Id, DateTime.Now, selectedTrainModel.Path.Id);
            await NotifyArrived();
        }
        catch (Exception e)
        {
            if (e is RailProcessException)
            {
                NotificationService.SetMessage(TypeNotification.Warning, e.Message);
            }
            else
            {
                NotificationService.SetMessage(TypeNotification.Error, "Не удалось выполнить операцию");
            }
            await CancelArrival();
        }
        await arrivingList.DeselectRow();
        await arrivedList.DeselectRow();
    }

    void onCancel()
    {
        Title = "Отмена прибытия поезда";
        Body = $"Отменить ранее переданное сообщение о прибытии поезда {arrivedList.selectedTrain.Num}?";
        CancelDialogIsVisible = true;
    }

    private async Task CancelArrival()
    {
        TrainModel train = arrivedList.selectedTrain;

        try
        {
            await GvcDataFetch.CancelMovingOperation(train.Id, ModelsLibrary.Codes.OperationCode.TrainArrival);
            await StationData.DeleteTrainAsync(train.Id);
            arrivedList.DeleteTrain(train);
            arrivingList.AddTrain(train);
            await arrivedList.DeselectRow();
            await arrivingList.DeselectRow();
            NotificationService.SetMessage(TypeNotification.Success, $"Операция по отмене прибытия поезда №{train.Num} проведена успешно");
        }
        catch (Exception exception)
        {
            if (exception is RailProcessException)
            {
                NotificationService.SetMessage(TypeNotification.Warning, exception.Message);
            }
            else
            {
                NotificationService.SetMessage(TypeNotification.Error, "Не удалось выполнить отмену прибытия");
            }
        }
    }

    private async Task Disband()
    {
        try
        {
            await GvcDataFetch.SendDisbanding(arrivedList.selectedTrain.Id, DateTime.Now);
            await StationData.DisbandTrain(arrivedList.selectedTrain);
            NotificationService.SetMessage(TypeNotification.Success, $"Операция по расформированию поезда №{arrivedList.selectedTrain.Num} завершена");
            arrivedList.DeleteTrain(arrivedList.selectedTrain);
        }
        catch (Exception e)
        {
            if (e is RailProcessException)
            {
                NotificationService.SetMessage(TypeNotification.Warning, e.Message);
            }
            else if (e is AggregateException)
            {
                foreach (Exception innerException in (e as AggregateException).InnerExceptions)
                {
                    NotificationService.SetMessage(TypeNotification.Warning, innerException.Message);
                }
            }
            else
            {
                NotificationService.SetMessage(TypeNotification.Error, "Не удалось выполнить операцию");
            }
        }
    }
}
