@page "/arrival"
@inject StationAssistant.Services.IGvcDataService GvcDataFetch
@inject StationAssistant.Services.IStationDataService StationData
@inject StationAssistant.Services.NotificationService NotificationService
@inject NavigationManager NavigationManager
@inject AuthenticationStateProvider authProvider

@using Microsoft.AspNetCore.SignalR.Client
@using Syncfusion.Blazor.Buttons
@using Syncfusion.Blazor.Popups
@attribute [AuthorizeRoles(Role.Admin, Role.DSC, Role.DSP)]

<div class="col-lg-12 control-section">
    <h3 class="text-center"> Прогноз прибытия поездов </h3>
    <div class="row">
        <div class="col-xs-4 col-sm-6 col-lg-12 col-md-12">
            <SfButton Disabled="selectedArrivingTrain == null" IsPrimary="true" IconCss="e-icons e-arriving" OnClick="(() => onOpenPathSelector(IsArriving:true))">Оформить прибытие</SfButton>
            <SfButton Disabled="selectedArrivingTrain == null" IsPrimary="false" IconCss="e-icons e-tgnl" OnClick="(async() => await GetDetails())">Получить ТГНЛ</SfButton>
        </div>
    </div>
    <div class="content-wrapper">
        <div class="row">
            <TrainList @ref="arrivingTrainList" trainList="arrivingTrains" IsOnStation="false" Height="230"
                       IsTrainSelected="(() => selectedArrivingTrain = arrivingTrainList.selectedTrain)"
                       IsTrainDeselected="(() => selectedArrivingTrain = null)" />
        </div>
    </div>
</div>
<div class="col-lg-12 control-section mt-1">
    <h3 class="text-center"> Прибывшие поезда </h3>
    <div class="col-xs-4 col-sm-6 col-lg-12 col-md-12">
        <SfButton IsPrimary="true" Disabled="selectedArrivedTrain == null" IconCss="e-icons e-disband" OnClick="(async() => await Disband())">Расформировать</SfButton>
        <SfButton IsPrimary="false" Disabled="selectedArrivedTrain == null" IconCss="e-icons e-relocate" OnClick="(() => onOpenPathSelector(false))">Переставить состав</SfButton>
        <SfButton IsPrimary="false" Disabled="selectedArrivedTrain == null" IconCss="e-icons e-arriving-cancel" OnClick="(() => CancelDialogIsVisible = true)">Отменить прибытие</SfButton>
    </div>
    <div class="content-wrapper">
        <div class="row">
            <TrainList @ref="arrivedTrainList" trainList="arrivedTrains" IsOnStation="true" Height="230"
                       IsTrainSelected="(() => selectedArrivedTrain = arrivedTrainList.selectedTrain)"
                       IsTrainDeselected="(() => selectedArrivedTrain = null)" />
        </div>
    </div>
</div>


@if (TrainCompositionVisible)
{
    <ConfirmModal Title="@String.Format($"Телеграмма-натурный лист поезда №{selectedTrainModel.Num}")"
              DialogClose="@(() => TrainCompositionVisible = false)"
              OverlayClick="@(() => TrainCompositionVisible = false)"
              OKClick="@(() => TrainCompositionVisible = false)"
              Width="850" Height="80%">
        <TrainComposition trainModel="selectedTrainModel" />
    </ConfirmModal>
}
else if (PathSelectorVisible)
{
    <ConfirmModal Title="@String.Format($"Путь {(isArriving ? "прибытия" : "")} для поезда №{selectedTrainModel.Num}")"
              DialogClose="@(() => PathSelectorVisible = false)"
              OverlayClick="@(() => PathSelectorVisible = false)"
              OKClick="@(async () => await onPathSelected(pathSelector.PathId))"
              Width="450px" Height="180px">
        <PathSelector @ref="pathSelector" selectedTrain="selectedTrainModel" ShowArrivingPathsOnly="isArriving" />
    </ConfirmModal>
}
else if (CancelDialogIsVisible)
{
    <SfDialog Header="Отмена прибытия поезда" Width="400px" ShowCloseIcon="true"
          Content="@String.Format($"Отменить ранее переданное сообщение о прибытии поезда {arrivedTrainList.selectedTrain.Num}?")">
        <DialogButtons>
            <DialogButton Content="Да" IsPrimary="true" OnClick="(async() => {CancelDialogIsVisible = false; await CancelArrival(); })" />
            <DialogButton Content="Нет" OnClick="(() => { CancelDialogIsVisible = false; })" />
        </DialogButtons>
    </SfDialog>
}

<style>
</style>


@code {
    PathSelector pathSelector;
    TrainList arrivingTrainList;
    TrainList arrivedTrainList;
    TrainModel selectedArrivingTrain;
    TrainModel selectedArrivedTrain;
    TrainModel selectedTrainModel;
    private List<TrainModel> arrivingTrains { get; set; }
    private List<TrainModel> arrivedTrains { get; set; }
    private bool TrainCompositionVisible { get; set; } = false;
    private bool PathSelectorVisible { get; set; } = false;
    private bool CancelDialogIsVisible { get; set; } = false;

    private bool isArriving = false;
    private HubConnection hubConnection;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            // TODO: Run task in parallel
            arrivedTrains = await StationData.GetArrivedTrainsAsync();
            arrivingTrains = await GvcDataFetch.GetArrivingTrains();
        }
        catch (Exception e)
        {
            if (e is RailProcessException)
            {
                NotificationService.SetMessage(TypeNotification.Warning, e.Message);
            }
            else
            {
                NotificationService.SetMessage(TypeNotification.Error, $"Не удалось загрузить поезда");
            }
        }

        // TODO: Move to subscribe to service
        hubConnection = new HubConnectionBuilder().WithUrl(NavigationManager.ToAbsoluteUri("/trainshub")).Build();
        hubConnection.On<string, TrainModel>("TrainArrived", (user, train) =>
            {
                NotificationService.SetMessage(user, $"Поезд {train.Num} прибыл на станцию");
                arrivingTrainList.DeleteTrain(train);
                arrivedTrainList.AddTrain(train);
            });
        await hubConnection.StartAsync();
    }

    // TODO: Move to service
    async Task NotifyArrived(TrainModel train)
    {
        var authState = await authProvider.GetAuthenticationStateAsync();
        var userName = authState.User.Identity.Name;
        await hubConnection.SendAsync("SendArrived", userName, train);
    }

    // TODO: Move to unsubscribe to service
    public async ValueTask DisposeAsync()
    {
        await hubConnection.DisposeAsync();
    }

    private async Task GetDetails()
    {
        try
        {
            selectedTrainModel = await GvcDataFetch.GetTrainInfo(selectedArrivingTrain.Id);
            TrainCompositionVisible = true;
        }
        catch (Exception e)
        {
            if (e is RailProcessException)
            {
                NotificationService.SetMessage(TypeNotification.Warning, e.Message);
            }
            else
            {
                NotificationService.SetMessage(TypeNotification.Error, "Не удалось выполнить операцию");
            }
        }
    }

    async Task onPathSelected(int selectedPathId)
    {
        PathSelectorVisible = false;

        if (isArriving)
        {
            await Arrived(selectedPathId);
        }
        else
        {
            await Relocate(selectedPathId);
        }
    }

    void onOpenPathSelector(bool IsArriving)
    {
        selectedTrainModel = (IsArriving ? selectedArrivingTrain : selectedArrivedTrain);
        isArriving = IsArriving;
        PathSelectorVisible = true;
    }

    private async Task Relocate(int pathId)
    {
        try
        {
            await StationData.RelocateTrain(selectedArrivedTrain.Id, pathId);
            selectedArrivedTrain.Path = await StationData.GetPathAsync(pathId);
            arrivedTrainList.UpdateSelectedRow(selectedArrivedTrain);
            NotificationService.SetMessage(
                TypeNotification.Success,
                $"Перестановка поезда №{selectedArrivedTrain.Num} на другой путь завершена");
        }
        catch (Exception)
        {
            NotificationService.SetMessage(TypeNotification.Error, "Не удалось установить путь для поезда");
        }
    }

    private async Task Arrived(int pathId)
    {
        try
        {
            selectedArrivingTrain.Path = await StationData.GetPathAsync(pathId);
            await GvcDataFetch.SendTrainArrivedAsync(selectedArrivingTrain.Id, DateTime.Now);
            await StationData.AddTrainAsync(selectedArrivingTrain.Id, DateTime.Now, selectedArrivingTrain.Path.Id);
            await NotifyArrived(selectedArrivingTrain);
        }
        catch (Exception e)
        {
            if (e is RailProcessException)
            {
                NotificationService.SetMessage(TypeNotification.Warning, e.Message);
            }
            else
            {
                NotificationService.SetMessage(TypeNotification.Error, "Не удалось выполнить операцию");
            }
            await CancelArrival();
        }
    }

    private async Task CancelArrival()
    {
        TrainModel train = arrivedTrainList.selectedTrain;

        try
        {
            await GvcDataFetch.CancelMovingOperation(train.Id, ModelsLibrary.Codes.OperationCode.TrainArrival);
            await StationData.DeleteTrainAsync(train.Id);
            arrivedTrainList.DeleteTrain(train);
            arrivingTrainList.AddTrain(train);
            await arrivedTrainList.DeselectRow();
            await arrivingTrainList.DeselectRow();
            NotificationService.SetMessage(TypeNotification.Success, $"Операция по отмене прибытия поезда №{train.Num} проведена успешно");
        }
        catch (Exception exception)
        {
            if (exception is RailProcessException)
            {
                NotificationService.SetMessage(TypeNotification.Warning, exception.Message);
            }
            else
            {
                NotificationService.SetMessage(TypeNotification.Error, "Не удалось выполнить отмену прибытия");
            }
        }
    }

    private async Task Disband()
    {
        try
        {
            await GvcDataFetch.SendDisbanding(arrivedTrainList.selectedTrain.Id, DateTime.Now);
            await StationData.DisbandTrain(arrivedTrainList.selectedTrain);
            NotificationService.SetMessage(TypeNotification.Success, $"Операция по расформированию поезда №{arrivedTrainList.selectedTrain.Num} завершена");
            arrivedTrainList.DeleteTrain(arrivedTrainList.selectedTrain);
        }
        catch (Exception e)
        {
            if (e is RailProcessException)
            {
                NotificationService.SetMessage(TypeNotification.Warning, e.Message);
            }
            else if (e is AggregateException)
            {
                foreach (Exception innerException in (e as AggregateException).InnerExceptions)
                {
                    NotificationService.SetMessage(TypeNotification.Warning, innerException.Message);
                }
            }
            else
            {
                NotificationService.SetMessage(TypeNotification.Error, "Не удалось выполнить операцию");
            }
        }
    }
}
